from flask import Flask, request, jsonify
from flask_cors import CORS

app = Flask(__name__)
CORS(app) # برای جلوگیری از مشکلات CORS در توسعه محلی یا اگر دامنه‌ها متفاوت باشند

def چیدمان_الگو_واقعی(عرض_پارچه, الگوها_ورودی):
    """
    این تابع باید منطق اصلی چیدمان الگوهای شما را پیاده سازی کند.
    ورودی:
        عرض_پارچه (float): عرض پارچه.
        الگوها_ورودی (list of lists/tuples): لیستی از ابعاد الگوها مثلا [[طول1, عرض1], [طول2, عرض2]].
    خروجی:
        لیستی از آبجکت‌ها یا None. هر آبجکت نشان‌دهنده یک الگوی چیده شده است
        و باید شامل x, y, width, length باشد.
        مثال: [{'x': 0, 'y': 0, 'width': 30, 'length': 20}, {'x': 0, 'y': 20, 'width': 40, 'length': 15}]
        اگر الگویی قابل چیدمان نیست، می‌توانید None برای آن برگردانید یا از لیست نتایج حذف کنید.
    """
    print(f"عرض پارچه دریافتی: {عرض_پارچه}")
    print(f"الگوهای دریافتی: {الگوها_ورودی}")

    # *************************************************************************
    # START: منطق نمونه بسیار ساده چیدمان (فقط برای تست، باید جایگزین شود)
    # این منطق فقط الگوها را زیر هم می‌چیند اگر عرضشان جا شود
    # و خروجی را با فرمت مورد انتظار جاوااسکریپت (x,y,width,length) برمی‌گرداند.
    # شما باید الگوریتم بهینه خودتان را اینجا پیاده‌سازی کنید.
    # *************************************************************************
    چیدمان_نهایی = []
    موقعیت_فعلی_y = 0
    for i, (طول_الگو, عرض_الگو) in enumerate(الگوها_ورودی):
        if عرض_الگو <= عرض_پارچه:
            چیدمان_نهایی.append({
                "x": 0, # در این مثال ساده، همه از x=0 شروع می‌شوند
                "y": موقعیت_فعلی_y,
                "width": عرض_الگو, # عرض الگو
                "length": طول_الگو # طول الگو
            })
            موقعیت_فعلی_y += طول_الگو
            print(f"الگوی {i+1} ({طول_الگو},{عرض_الگو}) چیده شد در x=0, y={موقعیت_فعلی_y - طول_الگو}")
        else:
            چیدمان_نهایی.append(None) # یا هر نشانه‌ای برای الگوی غیرقابل چیدمان
            print(f"الگوی {i+1} ({طول_الگو},{عرض_الگو}) قابل چیدمان نبود.")
    # *************************************************************************
    # END: منطق نمونه
    # *************************************************************************
    
    print(f"نتایج چیدمان ارسالی به فرانت: {چیدمان_نهایی}")
    return چیدمان_نهایی

@app.route('/api/calculate', methods=['POST'])
def handle_calculate():
    try:
        data = request.get_json()
        if not data:
            return jsonify({"message": "داده‌ای ارسال نشده است"}), 400

        عرض_پارچه = data.get('عرض_پارچه')
        الگوها = data.get('الگوها') # این باید لیستی از لیست‌ها باشد مثل [[طول, عرض], ...]

        if عرض_پارچه is None or الگوها is None:
            return jsonify({"message": "داده‌های ورودی 'عرض_پارچه' یا 'الگوها' ناقص است"}), 400
        
        if not isinstance(الگوها, list):
             return jsonify({"message": "'الگوها' باید یک لیست باشد"}), 400

        نتایج = چیدمان_الگو_واقعی(float(عرض_پارچه), الگوها)
        return jsonify(نتایج)

    except TypeError as e:
        print(f"TypeError: {e}")
        return jsonify({"message": f"خطا در نوع داده‌های ورودی: {e}"}), 400
    except Exception as e:
        print(f"Exception: {e}")
        return jsonify({"message": f"خطای داخلی سرور: {e}"}), 500

# این بخش برای اجرای محلی (localhost) است و Vercel مستقیما از 'app' استفاده می‌کند.
# if __name__ == '__main__':
#     app.run(debug=True, port=5001) # می‌توانید پورت را برای تست محلی تغییر دهید
